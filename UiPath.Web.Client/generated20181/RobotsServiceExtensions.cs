// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace UiPath.Web.Client20181
{
    using Models;
    using System.Collections;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Extension methods for RobotsService.
    /// </summary>
    public static partial class RobotsServiceExtensions
    {
            /// <summary>
            /// Post to the server a collection of heartbeats messages generated by the
            /// robots from a machine
            /// </summary>
            /// <remarks>
            /// Every 30 seconds the UiPath service running on a robot machine posts a
            /// collection of heartbeat messages (one for each robot hosted on the
            /// machine).
            /// The response is a collection of commands specific to all robots defined on
            /// that machine, including the ones that were added in the meanwhile.
            /// </remarks>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='hbts'>
            /// </param>
            public static IList<RobotCommand> SubmitHeartbeat(this IRobotsService operations, IList<HeartbeatDto> hbts)
            {
                return operations.SubmitHeartbeatAsync(hbts).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Post to the server a collection of heartbeats messages generated by the
            /// robots from a machine
            /// </summary>
            /// <remarks>
            /// Every 30 seconds the UiPath service running on a robot machine posts a
            /// collection of heartbeat messages (one for each robot hosted on the
            /// machine).
            /// The response is a collection of commands specific to all robots defined on
            /// that machine, including the ones that were added in the meanwhile.
            /// </remarks>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='hbts'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<IList<RobotCommand>> SubmitHeartbeatAsync(this IRobotsService operations, IList<HeartbeatDto> hbts, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                using (var _result = await operations.SubmitHeartbeatWithHttpMessagesAsync(hbts, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Post to the server a heartbeat collection with jobs information
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='heartbeats'>
            /// </param>
            public static void SubmitJobState(this IRobotsService operations, IList<HeartbeatDto> heartbeats)
            {
                operations.SubmitJobStateAsync(heartbeats).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Post to the server a heartbeat collection with jobs information
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='heartbeats'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task SubmitJobStateAsync(this IRobotsService operations, IList<HeartbeatDto> heartbeats, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                (await operations.SubmitJobStateWithHttpMessagesAsync(heartbeats, null, cancellationToken).ConfigureAwait(false)).Dispose();
            }

            /// <summary>
            /// Gets from the server all robots associated with a machine and having the
            /// specified licence key
            /// </summary>
            /// <remarks>
            /// Gets from the server all robots associated with a machine and having the
            /// specified licence key.
            /// </remarks>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='licenseKey'>
            /// The license key that the returned robots must have.
            /// </param>
            /// <param name='machineName'>
            /// The name of the machine that the returned robots must be associated with
            /// </param>
            public static IList<RobotDetailsDto> GetRobotMappings(this IRobotsService operations, string licenseKey, string machineName)
            {
                return operations.GetRobotMappingsAsync(licenseKey, machineName).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Gets from the server all robots associated with a machine and having the
            /// specified licence key
            /// </summary>
            /// <remarks>
            /// Gets from the server all robots associated with a machine and having the
            /// specified licence key.
            /// </remarks>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='licenseKey'>
            /// The license key that the returned robots must have.
            /// </param>
            /// <param name='machineName'>
            /// The name of the machine that the returned robots must be associated with
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<IList<RobotDetailsDto>> GetRobotMappingsAsync(this IRobotsService operations, string licenseKey, string machineName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                using (var _result = await operations.GetRobotMappingsWithHttpMessagesAsync(licenseKey, machineName, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Called by RobotSvc to connect the robots on the machine it is running on to
            /// Orchestrator (under automatic deployment).
            /// </summary>
            /// <remarks>
            /// This is the initial handshake between the robot service and Orchestrator,
            /// the equivalent of configuring the connection
            /// info from Robot tray (manual deployment). It is supported only for
            /// authorized machines, i.e. the robot machine is part of the
            /// same AD as Orchestrator. To enforce this, the request must contain the
            /// machine identity. The robots must be already provisioned
            /// in Orchestrator before this step, otherwise RobotSvc will continue to call
            /// this method until they are.
            /// </remarks>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='tenantId'>
            /// The tenant under which already defined robots are searched for.
            /// </param>
            public static ConnectionData GetConnectionData(this IRobotsService operations, int tenantId)
            {
                return operations.GetConnectionDataAsync(tenantId).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Called by RobotSvc to connect the robots on the machine it is running on to
            /// Orchestrator (under automatic deployment).
            /// </summary>
            /// <remarks>
            /// This is the initial handshake between the robot service and Orchestrator,
            /// the equivalent of configuring the connection
            /// info from Robot tray (manual deployment). It is supported only for
            /// authorized machines, i.e. the robot machine is part of the
            /// same AD as Orchestrator. To enforce this, the request must contain the
            /// machine identity. The robots must be already provisioned
            /// in Orchestrator before this step, otherwise RobotSvc will continue to call
            /// this method until they are.
            /// </remarks>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='tenantId'>
            /// The tenant under which already defined robots are searched for.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<ConnectionData> GetConnectionDataAsync(this IRobotsService operations, int tenantId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                using (var _result = await operations.GetConnectionDataWithHttpMessagesAsync(tenantId, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Acquire a license.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='identifier'>
            /// </param>
            public static void AcquireLicense(this IRobotsService operations, RobotIdentifier identifier)
            {
                operations.AcquireLicenseAsync(identifier).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Acquire a license.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='identifier'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task AcquireLicenseAsync(this IRobotsService operations, RobotIdentifier identifier, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                (await operations.AcquireLicenseWithHttpMessagesAsync(identifier, null, cancellationToken).ConfigureAwait(false)).Dispose();
            }

            /// <summary>
            /// Release active license.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='identifier'>
            /// </param>
            public static void ReleaseLicense(this IRobotsService operations, RobotIdentifier identifier)
            {
                operations.ReleaseLicenseAsync(identifier).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Release active license.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='identifier'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task ReleaseLicenseAsync(this IRobotsService operations, RobotIdentifier identifier, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                (await operations.ReleaseLicenseWithHttpMessagesAsync(identifier, null, cancellationToken).ConfigureAwait(false)).Dispose();
            }

            /// <summary>
            /// Gets from the server all the processes associated with a robot
            /// </summary>
            /// <remarks>
            /// Gets from the server all the processes associated with a robot
            /// </remarks>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='robotKey'>
            /// The unique key identifying the robot.
            /// </param>
            public static IList<PublishedProcess> GetAssociatedProcesses(this IRobotsService operations, string robotKey)
            {
                return operations.GetAssociatedProcessesAsync(robotKey).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Gets from the server all the processes associated with a robot
            /// </summary>
            /// <remarks>
            /// Gets from the server all the processes associated with a robot
            /// </remarks>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='robotKey'>
            /// The unique key identifying the robot.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<IList<PublishedProcess>> GetAssociatedProcessesAsync(this IRobotsService operations, string robotKey, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                using (var _result = await operations.GetAssociatedProcessesWithHttpMessagesAsync(robotKey, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

    }
}
